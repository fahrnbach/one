---
title: "Blog API"
description: "GraphQL API documentation for powering the blog CMS and frontend using Yoga, D1, and R2."
tags: ["api", "graphql", "yoga", "blog", "cms", "d1", "r2"]
author: "Jacob Fahrnbach"
ai_used: true
model: "ChatGPT 4o-Turbo"
status: "draft"
created: "2025-06-19"
updated: "2025-06-19"
revision: 1.0
alignment: 9
confidence: 9
---

import { Aside } from '@astrojs/starlight/components';

## Overview

This document outlines the structure and purpose of the Blog API, a GraphQL-based interface powered by [Yoga](https://the-guild.dev/graphql/yoga-server) and backed by a Cloudflare D1 database. The API is responsible for serving dynamic blog content to the Angular frontend and the internal CMS interface, enabling real-time editing, previewing, and content publishing.

The API architecture supports modular expansion and is built with scalability and clarity in mind. A schema reference will be provided in a companion document (`api/schema.mdx`), but core concepts and usage are covered here.

<Aside type="note">
The Blog API also reads from R2 when media assets (e.g., cover images, thumbnails) are referenced within blog frontmatter or rendered dynamically in the UI.
</Aside>

## Architecture

- **Framework**: GraphQL Yoga (Node.js runtime on Cloudflare Workers)
- **Database**: Cloudflare D1 (SQLite) for structured content and metadata
- **Media Storage**: Cloudflare R2 for static assets
- **Schema**: Defined separately, auto-typed with `graphql-codegen`
- **Frontend**: Consumed by Angular UI (blog viewer + admin panel)

## Core Functionality

- Query posts by slug, tag, category, or date
- Fetch full post content including frontmatter metadata
- Search and filter by keyword
- Return related posts (planned)
- Paginate through blog archives
- Mutations (admin-only):
  - Create/update/delete blog posts
  - Update tags, categories, and relationships
  - Upload new Markdown documents via CMS interface

## Deployment Model

- Runs on Cloudflare Workers
- D1 queries are optimized via prepared statements
- R2 asset URLs are publicly cacheable and optionally signed
- Request-level logging and access throttling built-in

<Aside type="tip">
All queries and mutations are strictly typed. You can introspect the schema or view auto-generated TypeScript types in the shared repo under `@types/blog-schema`.
</Aside>

## Example Use Case

> A blog post preview page in the CMS editor sends a GraphQL query for `getPostBySlug(slug: "sparkdoc-tools")`. The response contains the full Markdown content and all associated metadata — title, tags, publish date, cover image — rendered in real-time inside the Angular editor preview component.

## Related Files

- [`/core/api/schema`](/core/api/schema) — GraphQL schema specification
- [`/core/blog/blog-components/hot-posts`](/core/blog/blog-components/hot-posts) — UI components that consume this API
- [`/core/library/snippets`](#COMING_SOON) — Sample queries and mutations

<Aside type="caution">
Ensure D1 schema migrations are synced before deploying API changes. Use the provided SQL migration scripts.
</Aside>

---
```md
<!-- Prompt: Write an MDX SparkDoc describing the GraphQL Blog API architecture -->
<!-- AI Notes: Keep it clear, schema-light, and link to related tooling and schema references. Emphasize Yoga + D1 + Angular integration. -->
