---
title: Monorepo Setup (Nx)
description: Why we migrated to Nx, how it’s going, and what we’ve learned.
tags: ["nx", "monorepo", "tooling", "core"]
author: "Jacob Fahrnbach"
ai_used: true
model: "ChatGPT 4o-Turbo"
status: "draft"
created: "2025-06-19"
updated: "2025-06-19"
revision: 1.0
alignment: 10
confidence: 10
---
import { Aside } from '@astrojs/starlight/components';

# 🧩 Monorepo Setup (Nx)

When you’re building a constellation of connected tools like *fahrnbach.one*, managing them in isolated silos quickly becomes chaos. Enter **Nx**, the modular build system and monorepo manager that helped bring order to the galaxy.

---

## Why We Migrated

We started with a simple repo, but as we built out `blog`, `library`, `genie`, `nexus`, and more — it became clear we needed:

- 🚀 **Unified builds and deployments**
- 🧠 **Shared tooling and utility packages**
- 🧩 **Consistent conventions across apps**
- 🧪 **Easier local testing of interdependent modules**

Nx gave us just that — with workspace generators, dependency graphs, and the flexibility to house everything from Astro to Angular to Node workers in one place.

<Aside type="note">
If you’re thinking about scaling your side project or team into multiple apps — consider moving early. The migration pain grows the longer you wait.
</Aside>

---

## How It’s Going

Honestly? Pretty great. Some highlights:

- 🧱 Our apps now share a single `tsconfig.base.json`, unified lint rules, and library code
- 🛠️ We can spin up a new app or lib with a single CLI command
- 🔄 Graph-based builds avoid rebuilding apps unnecessarily
- 🧪 Tests and dev servers are scoped to individual apps

There’s still room for growth, especially around generating custom schematics and leveraging computation caching fully — but the foundation is solid.

---

## Quirks and Gotchas

Nx is powerful, but it isn’t magic. A few rough edges:

- 📁 **Naming conventions matter.** Accidentally duplicate app/lib names and you’ll see cryptic errors
- 🧪 **Dev server output can be noisy**, especially when switching apps quickly
- 🔗 **Implicit dependency tracking** sometimes needs a manual nudge (e.g., workspace.json or `namedInputs`)
- 🧵 **Inter-app testing** (e.g., `genie` using data from `blog`) still requires thoughtful mocking or shared test utils

---

## Why It’s Still Worth It

Despite the quirks, Nx has been transformational for our development workflow. The ability to:

- Traverse a dependency graph
- Share code between frontends and utilities
- Generate new features from the CLI
- Scope commands (`nx serve blog`, `nx test genie`) without polluting global state

...makes it the perfect fit for a growing universe like *fahrnbach.one*.

<Aside type="tip">
Stay tuned for future updates as we wire Nx into our CI/CD pipeline, add deploy targets, and publish library packages across our constellation.
</Aside>
